//! A tiny FAT16 “driver” example.
//!
//! This demonstrates:
//! - using `io-std` helpers (`read_specific`) to parse **little-endian on-disk structs**
//! - using the `derive` feature (`#[derive(Endianize)]`) to generate `*Wire` types
//! - using fixed-size UTF-16LE text fields (volume label) from the text features
//!
//! It is intentionally minimal (not a complete FAT implementation).
//!
//! Run:
//!
//! ```sh
//! cargo run --example fat16_driver --features "derive io-std text_all"
//! ```

#![cfg_attr(
    not(all(feature = "derive", feature = "io-std", feature = "text_all")),
    allow(dead_code, unused_imports)
)]

mod driver;
use simple_endian::{u16le, u32le};

#[cfg(all(feature = "io-std", feature = "text_all"))]
use simple_endian::{write_specific, FixedUtf16LeSpacePadded};
use std::io::{Cursor, Read, Seek, SeekFrom};

const BYTES_PER_SECTOR: usize = 512;
const DIR_ENTRY_SIZE: usize = 32;

fn ascii_trim_right(bytes: &[u8]) -> String {
    let end = bytes
        .iter()
        .rposition(|&b| b != b' ' && b != 0)
        .map(|i| i + 1)
        .unwrap_or(0);
    String::from_utf8_lossy(&bytes[..end]).to_string()
}

fn dir_entry_filename(name: &[u8; 8], ext: &[u8; 3]) -> String {
    let name = ascii_trim_right(name);
    let ext = ascii_trim_right(ext);
    if ext.is_empty() {
        name
    } else {
        format!("{name}.{ext}")
    }
}

fn build_toy_fat16_image() -> Vec<u8> {
    // Build a tiny in-memory “disk image”:
    // - sector 0: boot sector (512 bytes)
    // - sector 1: (dummy) FAT
    // - sector 2: root directory (we place one entry)
    let bytes_per_sector = BYTES_PER_SECTOR;
    let mut img = vec![0u8; 3 * bytes_per_sector];

    // --- Write boot-sector pieces into the 512-byte sector ---
    // Layout (classic):
    // 0x00: jump (3)
    // 0x03: OEM (8)
    // 0x0B: BPB (25)
    // 0x24: FAT16 extended (26) -- in the classic FAT16 boot sector this is the EBR region
    // 0x1FE: signature 0x55AA

        // Write jump + OEM as raw fixed-size byte buffers.
        {
            let boot1 = driver::BootJumpOem {
                jump: [0xEB, 0x3C, 0x90],
                oem: *b"MSDOS5.0",
            };
            img[0x00..0x03].copy_from_slice(&boot1.jump);
            img[0x03..0x0B].copy_from_slice(&boot1.oem);
        }

    // Write BPB using the generated wire type.
    // Offsets are from start of boot sector.
    #[cfg(all(feature = "derive", feature = "io-std", feature = "text_all"))]
    {
        // This type is generated by Endianize inside the driver module.
        let bpb: driver::BiosParameterBlockWire = driver::BiosParameterBlockWire {
            bytes_per_sector: (bytes_per_sector as u16).into(),
            sectors_per_cluster: 1u8.into(),
            reserved_sectors: 1u16.into(),
            fats: 1u8.into(),
            root_entries: 16u16.into(),
            total_sectors_16: 0u16.into(),
            media: 0xF8u8.into(),
            sectors_per_fat: 1u16.into(),
            sectors_per_track: 32u16.into(),
            heads: 64u16.into(),
            hidden_sectors: 0u32.into(),
            total_sectors_32: 3u32.into(),
        };

        let mut wcur = Cursor::new(&mut img[0x0B..0x24]);
        write_specific(&mut wcur, &bpb).expect("write BPB");
    }

    // FAT16 EBR fields.
    #[cfg(all(feature = "derive", feature = "io-std", feature = "text_all"))]
    {
        let ebr: driver::Fat16EbrWire = driver::Fat16EbrWire {
            drive_number: 0x80u8.into(),
            _reserved: 0u8.into(),
            boot_sig: 0x29u8.into(),
            volume_id: 0x1234_5678u32.into(),
        };
        let mut wcur = Cursor::new(&mut img[0x24..0x2B]);
        write_specific(&mut wcur, &ebr).expect("write FAT16 EBR");
    }

    // Volume label: for this demo we store it as fixed UTF-16LE (space padded)
    // to exercise the crate's text support.
    #[cfg(all(feature = "derive", feature = "io-std", feature = "text_all"))]
    {
        let label: FixedUtf16LeSpacePadded<11> = "VOL_LABEL".try_into().expect("label fits");
        let mut wcur = Cursor::new(&mut img[0x2B..0x2B + 22]);
        write_specific(&mut wcur, &label).expect("write volume label");
    }

    // fs_type is raw bytes in the boot sector; keep it raw bytes.
    // NOTE: must be written *after* the EBR chunk; it overlaps that region.
        {
            let fs_type = driver::FsTypeAscii8 {
                bytes: *b"FAT16   ",
            };
            img[0x36..0x3E].copy_from_slice(&fs_type.bytes);
        }

    #[cfg(all(feature = "derive", feature = "io-std", feature = "text_all"))]
    {
        // Boot sector signature (always little-endian 0xAA55).
        let sig: u16le = 0xAA55u16.into();
        let mut wcur = Cursor::new(&mut img[0x1FE..0x200]);
        write_specific(&mut wcur, &sig).expect("write boot signature");
    }

    // Root directory entry in sector 2.
    // Root directory entry bytes:
    // - name(8) + ext(3) are raw bytes
    // - the rest is the endianized scalar struct
    #[cfg(all(feature = "derive", feature = "io-std", feature = "text_all"))]
    {
        let root_sector_off = 2 * bytes_per_sector;
            let name83 = driver::ShortName83 {
                name: *b"HELLO   ",
                ext: *b"TXT",
            };
            img[root_sector_off..root_sector_off + 8].copy_from_slice(&name83.name);
            img[root_sector_off + 8..root_sector_off + 11].copy_from_slice(&name83.ext);
    }

    // Write the remaining 21 bytes of the entry using the generated wire type.
    // Offsets are from the start of the 32-byte directory entry.
    #[cfg(all(feature = "derive", feature = "io-std", feature = "text_all"))]
    {
        let root_sector_off = 2 * bytes_per_sector;
        let rest: driver::DirEntryRestWire = driver::DirEntryRestWire {
            attr: 0x20u8.into(),
            nt_reserved: 0u8.into(),
            ctime_tenths: 0u8.into(),
            ctime: 0u16.into(),
            cdate: 0u16.into(),
            adate: 0u16.into(),
            first_cluster_hi: 0u16.into(),
            mtime: 0u16.into(),
            mdate: 0u16.into(),
            first_cluster_lo: 2u16.into(),
            file_size: 13u32.into(),
        };

        let mut wcur = Cursor::new(&mut img[root_sector_off + 11..root_sector_off + 32]);
        write_specific(&mut wcur, &rest).expect("write dir entry rest");
    }

    img
}

fn main() {
    #[cfg(all(feature = "derive", feature = "io-std", feature = "text_all"))]
    driver::run();

    #[cfg(not(all(feature = "derive", feature = "io-std", feature = "text_all")))]
    eprintln!(
        "This example requires features: derive, io-std, text_all\n\n  cargo run --example fat16_driver --features \"derive io-std text_all\""
    );
}
